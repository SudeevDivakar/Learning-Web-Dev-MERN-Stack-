DOM:
->The DOM stands for Document Object Model
->The DOM is a JavaScript representation of a webpage.
->JS window into the contents of a webpage.

The document object is our entry point into the world of the DOM. It contains representations of all the content on a page along with a lot of useful methods and properties.
The doucument object is a tree of all the html elements present within the browser.


(SYNTAX) 
To see the object properties in a document, we use:
console.dir(document)


SELECTING AN ELEMENT BY ID:
->To select an element by its id, we use:
const hello = document.getElementById('hello');
->This gives us the object representation of an element with the ID 'hello'


SELECTING ELEMENTS BY TAG NAME AND CLASS NAME:
e.g)
const allImages = document.getElementsByTagName('img');
->The above code returns an html collection.(looks like an array but is not an array)
->Each of the elements in an html collection are objects.
->They are iterable collections but they are not arrays.
->HTML collections contain elements that represent html elements.
e.g)
const squareImages = document.getElementsByClassName('square');
->The above code returns an html collection containing elements that belong to the same class.
->Each of these elements are an object.
Note:- If the class name does not exist, we get an empty html collection. If the specified does not exist, we recieve null. 


NEW WAY OF SELECTING ELEMENTS:
document.querySelector('p');
document.querySelector('#banner');
document.querySelector('.square');
The querySelector method only retrieves the first occurance of a tag, id, class.

->To select specific tags we can use:
document.querySelector('.square:nth-of-type(3)');
                    OR
document.querySelector('p:nth-of-tpe(2)');
document.querySelector('a[title="Java"]');

->We can also use querySelectorAll() to retrieve all instances of a specified tag/class.
document.querySelectorAll('p');
document.querySelectorAll('.square');
Both the above statements return all instances of the tag/class.
->We can also use descendant selectors:
document.querySelectorAll('.square p');       //All paragraph tags within elements of the square class

e.g)
let links = document.querySelectorAll('p a');       //All anchor tags within paragraphs  
for (let link of links){
    console.log(link.href);
}


innerText PROPERTY:
->Returns the visible text present in between the opening and closing tags of a specific tag.
document.querySelector('p').innerText; 
The above code returns the visible text present in between an opening and closing tag.
e.g)
const allLinks = document.querySelectorAll('a');
for(let link of allLinks){
    link.innerText = 'I AM A LINK';
} 


textContent PROPERTY:
->Returns all text(pieces of content) present between the opening and closing tag even if it is hidden. 
->Returns the content with similar markup.
e.g)
document.querySelectorAll('p').textContent;


Note:- The above two properties cannot be used to add in html elements onto the webpage.


innerHTML PROPERTY:
->The innerHTML property is used to retrieve all the html tags along with the text present in between the opening and closing tags of the specific element. 
->This property can be used to change/add html elements onto a webpage.
e.g)
document.querySelector('h1').innerHTML = "<i>Hello</i>";
document.querySelector('h1').innerHTML += "<sup>LOL</sup>";


ATTRIBUTES
->Attributes on an element can be href,src,type,id,class,etc.
->We can change these Attributes using JavaScript.
e.g)
const changeId = document.querySelector('#banner');
changeId.id = 'whoops';
The above code changes the id of an element from banner to whoops.
Note:- This will not change the name of the id in the css style sheets, so be careful.

(SYNTAX)
const firstLine = document.querySelector('a');
firstLine.getAttribute('href');
The difference between the above stated method and firstLine.href is that, the above stated method gets the href directly from the html file whereas firstLine.href gets it from the javascript object.
The outputs of both the functions are the same most of the time. 

(SYNTAX)
const firstLine = document.querySelector('a');
firstLine.setAttribute('href','www.google.com');
The set attribute is used to set the value of a specified property in javascript to a value of our choice.



CHANGING STYLES:
->In javascript, css properties like font-size and border-color are represented using camel case.
e.g) fontSize,borderColor,etc.
->Select the element you want to style using the querySelector command.
->The style property gives us access to all the different style properties that can be applied onto an element.
e.g)h1.style.color , p.style.fontSize 
->The style property does not contain any styles from the css worksheet and only contains inline styles.
->All property values have to be in a string
e.g)
h1.style.fontSize = '3em';
h1.style.border = '2px solid pink';
Note:- The above method is not an ideal method for changing styles using javascript because it only interacts with inline styles.


->To see the final changes made to an element, we can use the window.getComputedStyle(element_name) which returns an object containing the final styles of the specified element.
e.g)
let h1 = document.querySelector('h1');
let properties = window.getComputedStyle(h1);
console.log(properties.color);
Note:- Only used to view the properties and values.


To change styles without adding them to the inline style sheet, we can:
->Create a class style on the external css sheet and then assign an element the class name using the setAttribute property 
->However, this method would override the existing class on the element and would only apply only the mentioned class style on the element
e.g)
const h2 = document.querySelector('h2');
h2.setAttribute('class','purple');
->To apply more than one class styles onto an element, we use:
e.g)
let currentClasses = h2.getAttribute('class');
h2.setAttribute = ('class' , `${currentClasses} border`);
Note:- The above method is tedious as well and thus we usually prefer the following method.


The classList method:
->The classList method makes out life more easier
->To view the current classes on an element, we use:
e.g)
let h1 = document.querySelector('h1');
h1.classList;
->To add a class onto the class list, we use the:
e.g)
let h1 = document.querySelector('h1');
h1.classList.add('purple');
->To remove a class from an element, we use:
e.g)
let h1 = document.querySelector('h1');
h1.classList.remove('purple');
->To check whether an element contains a class, we use:
e.g)
let h1 = document.querySelector('h1');
h1.classList.conatins('purple');            //returns a boolean value 
->To toggle classes(turn them off and on), we do:
e.g)
let h1 = document.querySelector('h1');
h1.classList.toggle('purple');  



NAVIGATING/TRAVERSING
->To access the parent element of an element, we can use:
e.g)
let firstBold = document.querySelector('b'); 
let parent = firstBold.parentElement;
Note:- Every element only has one parent element but a parent element can have multiple child elements. 
->To access children we can use firstBold.children;
->The above property returns to us an HTML collection which we can iterate over.
e.g)
let firstp = document.querySelector('p'); 
let children = firstp.children;
for(let i of children){
    console.log(i);
}
->To navigate through siblings we can use nextSibling,previousSibling,nextElementSibling,previousElementSibling.
->nextSibling and previousSibling both return the next node(white spaces and new lines)
->nextElementSibling and previousElementSibling the adjacent element sibling.


ADDING NEW ELEMENTS:
->To add new elements, we must first create a new element using document.createElement();
e.g)
const newImg = document.createElement('img');
newImg.src = 'https://b.fssta.com/uploads/application/soccer/headshots/53004.vresize.350.350.medium.20.png';
newImg.classList.add('square');
document.body.appendChild(newImg);
e.g)
const newPara = document.createElement('h2');
newPara.innerText = 'I am new!';
document.body.appendChild(newPara);

->We can also use the .append() method to flexibly append stuff onto an element. This makes the appended item the last child of the specified element.
e.g)
const p = document.querySelector('p');
p.append('hello my name is sudeev.');
p.append('lol','whats up?');
->We can also use .prepend() to prepend stuff at the start of the specified element contents.
e.g)
const p = document.querySelector('p');
const newB = document.createElement('b');
newB.append('Hi');
p.prepend(newB);

->The above two methods seen can only be used to add elements at the start or at the end of a specified element's contents.
->To add elements in between , we can use:
(SYNTAX)
targetElement.insertAdjacentElement(position,element);
->The position is a DOMString representing the position relative to the targetElement. Could be:
'beforebegin' : Before target element itself
'afterbegin' : Inside target element, just before the first child 
'beforeend' : Inside target element, after it's last child
'afterend' : After the targetElement itself 
e.g)
const newElement = document.createElement('h2');
newElement.append('<i>LOL</i>');
const h1 = document.querySelector('h1');
h1.insertAdjacentElement('afterend',newElement);

->We can also use:
const h3 = document.createElement('h3');
h3.innerText = "Hello";
let h1 = document.querySelector('h1');
h1.after(h3);
h1.before(h3);
->The .after() method adds an element after a specified element.
->The .before() element adds an element before a specified element.
Note:- Does not have complete browser support.(Internet Explorer)


REMOVING ELEMENTS:
->The old method was to use .removeChild(child_element) on the parent child to remove the child.
e.g)
let b = document.querySelector('b');
b.parentElement.removeChild(b);
->However this old method was tedious and thus we use the new method.
->The new way is .remove()
e.g)
let b = document.querySelector('b');
b.remove();
Note:- Does not have internet explorer support.



EVENTS:
->Events are responding to the user inputs and actions.
e.g)
click,drag,drop,hover,scroll,etc.
Note:- Events in javascript are not camel cased.


INLINE EVENTS:
->These are not recommended.
->Inline events are events written on the javascript file itself.
e.g)
<h1>Events</h1>
<button onclick="alert('You clicked me!'); alert('Stop clicking me');">Click Me!</button>
->The above code runs the first alert on the first click and the second alert on the second click.


EVENTS IN A SEPERATE FILE USING ATTRIBUTES:
->We get the element we need and assign a function to a property.
e.g)
let btn = document.querySelector('button');
btn.onclick = function() {
    alert('You clicked me');
}
btn.mouseenter = function(){
    console.log('AHH STOP TOUCHING ME');
}
->The onclick attribute executes a function when the element is clicked.
->The ondblclick function executes a function when it is double clicked.
->The onmouseenter function executes a function when the mouse enters the region of the element.


EVENTS IN A SEPERATE FILE USING addEventListener:
e.g)
const button = document.querySelector('button');
button.addEventListener('click',() => {
    alert('You clicked me');
});
e.g)
const button = document.querySelector('button');
button.addEventListener('dblclick',() => {
    alert('You clicked me');
});
->The reason why this method for events is better than the other two is because we can apply more than a single function for the same event.
->It also has more flexibility.
e.g)
const button = document.querySelector('button');
button.addEventListener('dblclick',scream,{once : true});    //only runs the Event once and automatically removes it after it's used.


EVENTS WITH THE 'this' keyword:
->If we want to use the same event listener function on multiple event listeners, we can use the this keyword to alter styles of the invoked object.
e.g)
const buttons = document.querySelectorAll('button');
for(let button of buttons){
    button.addEventListener('click',colorize);
} 
function makeRandColor(){
    let r = Math.floor(Math.random()*256);
    let g = Math.floor(Math.random()*256);
    let b = Math.floor(Math.random()*256); 
    return `rgb(${r},${g},${b})`;
}
function colorize(){
    this.style.backgroundColor = makeRandColor();
    this.style.color = makeRandColor();
}


EVENT OBJECTS:
->An event object is automatically passed to the function in the event listener.
->This object contains all the information about the user input.
->We can capture this object by specifying a parameter(usually called evt)
e.g)
h1.addEventListener('click',function (evt){
    console.log(evt);
});


KEYBOARD EVENTS:
->Events based on inputs given by the keyboard.
e.g)
let input = document.querySelector('input');
input.addEventListener('keyup',function(){
    console.log('KEYUP');
});
input.addEventListener('keydown',function(){
    console.log('KEYDOWN');
});

->To retrieve the value of the key and the actual key pressed, we can use:
e.g)
let input = document.querySelector('input');
input.addEventListener('keydown',function(evt){
    console.log(evt.key);                           // returns the key value entered e.g- SHIFT,a,etc.
    console.log(evt.code);                          // returns the actual key pressed e.g- ShiftLeft,ShiftRight,etc.
});
Note:- Can also be used for Mouse Events.



FORM EVENTS:
->When we submit a form, we usually specify an action attribute which redirects the page to a different page.
->When we would want to avoid this, we use:
e.g)
const form = document.querySelector('#shelterForm');
form.addEventListener('submit',function(evt){
    evt.preventDefault();
    console.log('Submitted');
});

->To retrieve the value from an input tag, we use:
e.g)
const form = document.querySelector('#shelterForm');
form.addEventListener('submit',function(evt){
    evt.preventDefault();
    let input = document.querySelector('input');
    let valueInsideInput = input.value;
    console.log(valueInsideInput);
    input.value = '';                         //Used to remove the input value present in the input box after submission
});   

->After selecting the form element and storing it in a variable, the variable has an 'elements' property which returns an object containing all the information about the form.
->Using the name attribute of the input tag, we can access the specific input tag and its corresponding value.
e.g)
const form = document.querySelector('#shelterForm');
form.addEventListener('submit',function(evt){
    evt.preventDefault();
    console.log(form.elements.username.value);      
    console.log(form.elements.password.value);           //prints contents of input elements assuming the name attributes assigned to the tag are username and password.
});


THE change EVENT:
->The change event is fires when the input is blurred(when the input box is deselected)
->Only works when new new input is entered and the input box is deselected.
e.g)
const input = document.querySelector('input');
input.addEventListener('change',function (evt){
    console.log('Change Event');
});


THE input EVENT:
->The input event fires whenever the input changes.
e.g)
const input = document.querySelector('input');
input.addEventListener('input',function (evt){
    h1.innerText = input.value;
});


EVENT BUBBLING:
->When an element is present within its parent element and both elements have event listeners on them, the child element inherits both the events.
->Thus we could end up with unnecessary events on the child element.
e.g)
<p onclick="alert('paragraph clicked');">
    I am a paragraph:
    <button onclick="alert('button clicked')">Click</button>
</p> 
->In the above case, the button gets both events and hence gets two alerts when it is clicked. We do not want that.
->To fix this we use:
e.g)
const button = document.querySelector('button');
button.addEventListener('click',function(evt){
    alert('button clicked');
    evt.stopPropogation();
});
->The evt.stopPropogation() method prevents event bubbling.


EVENT DELEGATION:
->When we use an event on a html file, the events only work on elements already present in the html file. They do not work on elements added later on using javascript.
->To fix this, we use an event listener on the parent element and then use the evt.target property of the event object.
->The 'target' property returns to us the child element that was clicked and we can perform operations on that element.
e.g)
const ul = document.querySelector('ul');
ul.addEventListener('click',function(evt){
    if(evt.target.nodeName === 'LI'){
        evt.target.remove();
    }
});
->The above code will remove all list items from the ul(newly added and previously present ones).


