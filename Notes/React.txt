REACT:
-> World's most popular front end library
-> Library that helps us build user interfaces from components that we can define
-> We can assemble smaller components to build larger applications


COMPONENETS:
-> Combine HTML and logic into a single reusable function.
-> Components are usually HTML with CSS and JS


NOTE: Use code sandbox for practicing react.


JSX:
-> JSX is a syntax extension for javascript.
-> Allows us to write markup that looks like HTML directly inside of our Javascript
-> It's not legal JS on it's own, so it must be transpiled.
-> Babel takes code that is not real javascript and transpiles it into real javascript.


BASIC REACT APP STRUCTURE:
-> Conventions that most react apps follow
-> There should be present a component called App.js 
-> App is the top level component of the entire application
-> All the components are rendered at the end of the day as part of a single component called App.
-> This App component is rendered in the index.js file (which puts the content onto the index.html file)


WRITING COMPONENETS:
-> Writing a function where the first letter of the function name is in uppercase.
e.g)
function Header() {
    return <h1>I'm a header component!</h1>
}
-> To render this component, in the App function, add '<Header/>'
e.g)
import "./styles.css";

function Greeter() {
  return <h1>Hello!</h1>;
}

export default function App() {
  return (
    <div className="App">
      <Greeter/>
      <h2>Hehe YeaBwoi</h2>
      <input type="text" placeholder="Hello" />
    </div>
  );
}



WRITING COMPONENETS IN DIFFERENT FILES:
-> We should generally write our components in different files with the names of each of these files being the same as the name of the function.
-> Add 'export default' at the beginning of the function definition in the new file.
e.g)
export default function Header() {
    return <h1>Hello<h1/>
}

-> We can also add a line at the end of the file to export our components 
e.g)
function Header() {
    return <h1>Hello<h1/>
}
export default Header;

-> In the App.js file, import the function from the new component file we just created.
e.g)
import Greeter from './Greeter';

-> To export multiple functions/components we can also do:
e.g)
function Header() {
    return <h1>Hello<h1/>
}
export {Header};
-> To export multiple components, just seperate it with a comma.

-> To import this, we can do:
e.g)
import {Header} from './Header';
-> Note: The name in both the export and import statements must match.



JSX RULES:
-> We must explicitly close self-closing elements like <br/>
-> Components can only return a single element.
-> Therefore to overcome this issue, we can return multiple elements wrapped in a div tag.
e.g)
export default function LoginForm() {
  return (
    <form>
      <input type="text" placeholder="Username" />
      <input type="password" placeholder="Password" />
      <br />
      <button>Login</button>
    </form>
  );
}
            (OR)
e.g)
export default function LoginForm() {
  return (
    <div>
      <input type="text" placeholder="Username" />
      <input type="password" placeholder="Password" />
      <br />
      <button>Login</button>
    </div>
  );
}



REACT FRAGMENTS:
-> When we do not want to return multiple elements enclosed in a div tag (as it clutters up the html document with unnecessary div tags), we can use react fragments.
e.g)
export default function LoginForm() {
  return (
    <>
      <input type="text" placeholder="Username" />
      <input type="password" placeholder="Password" />
      <br />
      <button>Login</button>
    </>
  );
}



EVALUATING JS EXPRESSIONS IN JSX:
-> To do this, we must carry out any expressions within {}. The {} escape the JSX syntax and treats anything inside it as pure javascript.
e.g)
export default function Greeter() {
    return <h1>Hello I'm sudeev! and my age is {2023 - 2003}</h1>;
}
            (OR)
e.g)
export default function Greeter() {
    const age = 20;
    return <h1>Hello I'm sudeev! and my age is {age}</h1>;
}



STYLING COMPONENETS:
-> While trying to specify the value of the class of a html tag in jsx, remember that class is a reserved keyword for javascript 
-> Therefore we use 'className' instead of class while using html in jsx
-> Convention is to usually create a new style sheet for each component and add styles onto it.


GEN1 POKEDEX USING REACT:
-> App.js
import "./styles.css";
import "./Pokemon.css";
import Pokemon from "./Pokemon";
export default function App() {
  return (
    <div className="App">
      <Pokemon></Pokemon>
    </div>
  );
}

-> Pokemon.js
import Die from "./Die.js";
export default function Pokemon() {
  const rand = Die();
  const url = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${rand}.png`;
  return (
    <div className="Pokemon">
      <h1>Pokemon #{rand}</h1>
      <img className="image" src={url} alt="" />
    </div>
  );
}

-> Die.js
export default function Die() {
  const rand = Math.floor(Math.random() * 151) + 1;
  return rand;
}

-> Pokemon.css
.Pokemon {
  color: blue;
  border: 5px solid black;
  width: 250px;
  border-radius: 20px;
}
.image {
  width: 160px;
  height: auto;
}



RUNNING LOCAL REACT APPS:
-> We use vite to setup a react environment.
-> To create a new react environment, run:
e.g)
npm create vite@latest 
-> We then have to enter a name for our project (this will be the name of the folder created)
-> Once we enter a name, we have to change our current working directory to the newly created folder.
-> We then run 'npm install' to download all the dependencies.
-> Now to start up our server, we run 'npm run dev'
-> We can also use 'create react app' to create a react environment for us.



PROPS:
-> Props are like arguments that we can provide to our components
-> We use props to make configurable components
e.g)
<Greeter name="Sudeev" />
-> In the JSX file, we need to mention an argument in the function definition. This argument will be an object. We can also destructure it in the function definition and use it as a normal variable.
e.g)
export default function Die(props){
    const rand = Math.floor(Math.random() * props.numSides) + 1;
    return <h1>Your lucky number is {rand}</h1>
}
-> To input multiple props, we can do:
e.g)
<Greeter name="Sudeev" color="black" />



PASSING NON-STRING PROPS:
-> To pass in number props, we can specify the value in {}
e.g)
<Greeter numSides={6} />
-> To pass in a list of values, we can:
e.g)
<ListPicker values={[1,2,3]} />
-> To pass in a objects, we can:
e.g)
<ListPicker values={{a: 1, b: 2, c: 3}} />



DEFAULT PROP VALUES:
-> To add default prop values, we do:
e.g)
export default function Die({numSides = 6}){
    const rand = Math.floor(Math.random() * numSides) + 1;
    return <h1>Your lucky number is {rand}</h1>
}



REACT CONDITIONALS:
e.g)
{num1 === num2 ? <h1>You win :)</h1> : <h1>You lose :(</h1>}
-> In the above example, if we do not have an else condition, we can also do:
e.g)
{num1 === num2 && <h1>You win :)</h1>}
-> Ternary operator is very useful while using react.
-> Refer to FirstReactApp/src/DoubleDice.jsx for more info



ADDING DYNAMIC COMPONENT STYLES:
-> We can define a 'style' attribute on a tag and set it's value to an object containing the styles we want to dynamically add.
e.g)
export default function DoubleDice(){
    const num1 = Math.floor(Math.random() * 3) + 1;
    const num2 = Math.floor(Math.random() * 3) + 1;
    const styles = { color : num1 === num2 ? 'green' : 'red'}
    return(
    <div className="DoubleDice" style={styles}>
        {num1 === num2 ? <h1>You win :)</h1> : <h1>You lose :(</h1>}
        <p>Num1: {num1}</p>
        <p>Num2: {num2}</p>
    </div>
    );
}
-> This can also be done as such:
e.g)
export default function ShoppingList({list}) {
    return(
        <ul>
            {list.map((i) => (
                <li style={{color: i.completed === true ? 'gray' : '' , textDecoration: i.completed === true ? 'line-through' : ''}}>
                    <b>{i.item}</b> - {i.quantity}
                </li>
            ))}
        </ul>
    );
}
-> Refer to FirstReactApp/src/DoubleDice.jsx for more info



RENDERING ARRAYS WITH MAP:
-> When we try to render an array using react, all the elements are taken and joined together and displayed in the browser.
-> To overcome this, we need to render each element as a tag 
-> We use the map function to turn each element into a tag
e.g)
export default function ColorList({colors}){
    const lis = colors.map((color) => <li>{color}</li>);
    const styles = {color: 'magenta'};
    return (
        <div style={styles}>
            <h3>List of colors used:</h3>
            <ul>
                {lis}
            </ul> 
        </div>
    );
} 



THE KEY PROP:
-> The key prop is added to a child tag of the tag being returned to provide it an unique identifier.
-> React requires an unique identifier for each of its existing child elements.
e.g)
export default function ShoppingList({list}) {
    return(
        <ul>
            {list.map((i) => (
                <li key={i.id} style={{color: i.completed === true ? 'gray' : '' , textDecoration: i.completed === true ? 'line-through' : ''}}>
                    <b>{i.item}</b> - {i.quantity}
                </li>
            ))}
        </ul>
    );
}


Note : It's good to implement more components in your application as it helps with reusability as well as implementing any future features


PASSING PROPS USING THE SPREAD OPERATOR:
-> As long as the data being passed and the props have the same name, we can use the spread operator to pass props in component calls.
e.g)
export default function Hello({greet, name, age}){
  return(
    <div>
      <p>{greet}, my name is {name} and my age is {age}</p>
    </div>
  );
}
-> This can be called as:
e.g)
<Hello {...i} />
where, i is an object containing key value pairs which have the same name as the props.



TURNING OFF REACT PROP TYPES:
-> To do this, in the .eslintrc.cjs file, under rules add 
"react/prop-types": "off"



PROPTYPES:
-> If we're not using typescript, we can use prop types to specify the datatypes of the props.
e.g)
import PropTypes from "prop-types";

export default function ListItem({ id, item, quantity, completed }) {
    return(
        <li key={id} style={{color: completed === true ? 'gray' : 'red' , textDecoration: completed === true ? 'line-through' : ''}}>
                <b>{item}</b> - {quantity}
        </li>
    )
}

ListItem.propTypes = { 
    item: PropTypes.string,
    quantity: PropTypes.number,
    completed: PropTypes.bool
};



REACT EVENTS:
-> To do this, we set the events within the tag as an attribute.
-> The events are all camel cased.
-> The specified event must refer to a function that will be called once the event is triggered.
-> We do not use () after specifying the function name as that would directly call the function.
e.g)
function clickHandler(){
    console.log('Hello');
}

export default function Clicker() {
    return(
        <div>
            <p>Click the button</p>
            <button onClick={clickHandler}>Click</button>
        </div>
    );
}



NON-CLICK EVENTS:
-> To refer to other non-click events, refer to https://developer.mozilla.org/en-US/docs/Web/Events
e.g)
function clickHandler(){
    console.log('You clicked!');
}

function handleHover(){
    console.log('You Hovered!');
}

export default function Clicker() {
    return(
        <div>
            <p onMouseOver={handleHover}>Hover over me</p>
            <button onClick={clickHandler}>Click</button>
        </div>
    );
}



EVENT OBJECT:
-> An event object is automatically passed onto the event handler function which can then be used for various reasons (stop propogation, prevent default, etc).
e.g)
function submitHandler(evt){
    evt.preventDefault();
    console.log('Submitted the form!');
}
export default function Form() {
    return(
        <form onSubmit={submitHandler}>
            <button>Submit</button>
        </form>
    );
}


NOTE: Props are immutable


STATE:
-> For the given code
e.g)
export default function Counter() {
    let num = 0;
    const incrementNum = () => {
        num += 1;
    }
    return(
        <div>
            <p>The count is: {num}</p>
            <button onClick={incrementNum}>Increment</button>
        </div>
    );
}
-> React will not increase the value of num, everytime the button is clicked, as the paragraph only gets rendered once and thus the output will always be 0
-> We use state to overcome this issue
-> State values can change
-> Everytime state data is changed, it is re-rendered onto the browser.



WHAT GOES IN STATE:
-> Data fetched from API 
-> Form Information 
-> Variable that decides whether something is showing or hidden 
-> If the value will change, it is a state 



USING STATE:
-> We create a state using the useState hook
-> A hook is a function that react gives us which we can incorporate into our own components to add some functionality 
e.g)
const [count, setCount] = useState(0);

-> The above code returns an array containing two elements:
    The piece of state itself (a variable) whose initial value will be whatever is passed into the ()
    A function to change the piece of state
-> For example, the piece of state is 'count', function is 'setCount' and the initial value is 0.
-> We must always call useState inside a component.
-> We can have multiple pieces of state in a single component.
-> A working incrementer function, looks like this:
e.g)
import {useState} from 'react';

export default function Counter() {
    let [num, setNum] = useState(0);
    function changeNum(){
        num += 1;
        setNum(num);
    }
    return(
        <div>
            <p>The count is: {num}</p>
            <button onClick={changeNum}>Increment</button>
        </div>
    );
}


NOTE: Everytime a state value is changed, the entire component is rendered again (except the useState initialization).



