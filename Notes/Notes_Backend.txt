TERMINAL:
-> Text based prompt used to interact with the machine.
-> Terminal is faster
-> Shell is the program running on the Terminal


COMMANDS:
-> The 'ls' command lists all the directories present in the current directory.
-> The 'pwd' command lists out the current directory path.
-> The 'cd <new_dir_name>' command changes the current working directory to a directory present within the current working directory.
-> The 'cd ..' command moves the working directory to the parent directory of the current working directory.

-> Absolute paths are those that can be referenced from any folder in the computer whereas relative paths are those that can only be accessed from the working directory.
e.g)
-> Absolute Path:
Note- The '\' signifies the root directory
cd \Users\sudee
cd \
-> Realtive Path:
Assuming we are in Courses folder, 
cd 'Web Development'/Notes
cd ../Sem-V

-> The 'mkdir <new_dir_name>' creates a new folder/directory in the current working directory. We can create multiple new directories/folders.
-> The 'man <command>' command provides us with a description of the specified command along with the flags we can use on it.
-> The 'touch <file_name>.<extension>' command creates files in the working directory. We can create multiple files at a time. Also sets the modification and access times in files.
-> The 'rm <file_names>' command can be used to remove files. Can remove multiple files at once. Once removed, cannot be restored again.
-> The 'rmdir <folder_name>' command can be used to remove folders. Can only remove empty folders.
-> The 'rm -rf <folder_name>' command can be used to remove folders that have contents within them. Once removed, cannot be restored again.


NODE JS:
-> JavaScript runtime
-> Implementation of JavaScript that runs outside the browser. 
-> Used to create Web Servers, video games, drone software, native apps(vs code), command line tools.


NODE REPL:
-> Its the equivalent of the JavaScript web console but on the terminal.
-> To activate, type 'node' in the terminal and enter.
-> DOM API's are not present.
-> The 'global' scope(contains setTimeout, etc) in the node REPL is the the equivalent of the window (top level element)
-> Contains modules that can interact with files and do other stuff the web browser cannot.


RUNNING FILES IN NODE:
-> To run files in node, first create a JavaScript file and in the node repl, run 'node <file_name>' .This will run the javascript file.
-> The import(python) equivalent in javascript is require()
e.g)
const fs = require('fs');


PROCESS:
-> Object in global that provides information about and control over the current Node.js process.
-> Always available to Node.js applications without the need of require().
-> Has info like current working directory, memory usage, etc.  
-> process.argv property returns an array containing the command line arguments passed when the node.js process was launched.
-> The first element will be process.execPath (Where the node executable is)
-> The second element will be the file that we are executing.
-> The remaining elements will be any arguments passed during launch.
e.g)
node greeter.js sudeev sunil


MODULE EXPORTS:
-> We can export certain variables, functions from a javascript file onto other files.
-> There exists a module.exports object (default to an empty object) to which we can add on our properties and methods.
-> Only the properties, methods added onto the module.exports object can be required from another file.
e.g)
(math.js file)
const add = (x,y) => x + y;
const PI = 3.14;
const square = x => x * x;
module.exports.add = add;
module.exports.PI = PI;
module.exports.square = square;

(app.js file)
const math = require('./math');               // '.' refers to the current directory
console.log(math);                            // Will contain add, PI and square properties/methods

-> We can also create an object containing all the necessary information to export and then assign the module.exports object with our created object.
e.g) module.exports = <created_object>;


REQUIRING A DIRECTORY:
-> When we want to require the contents of an entire directory, we create a index.js file in the directory exporting all the necessary information from that directory.
-> When node tries to require the contents of a directory, it searches for an index.js file in the directory and requires everything from the index.js file only.
e.g)
(cookie.js file)
module.exports = {
    name : 'cookie',
    color : 'blue'
};

(lovely.js file)
module.exports = {
    name : 'lovely',
    color : 'yellow'
};

(index.js file)
const cookie = require('./cookie');
const lovely = require('./lovely');
const allPets = [cookie,lovely];
module.exports = allPets;

(All the above files are in a Pets folder)

(app.js file present in the same directory as the Pets folder)
const pets = require('./Pets');
console.log(pets);                          //will print [ { name : 'cookie', color : 'blue' } , { name : 'lovely' , color : 'yellow' } ] 


NPM:
-> Node Package Manager
-> Library of thousands of packages published by other developers that we can use for free.
-> Command line tool to easily install and manage the packages in our node projects.
-> Kind of like pip for python 
-> 'npm install <package_name>' installs the package locally in the working directory.
-> 'npm install -g <package_name>' installs the package globally.


PACKAGE.JSON FILE:
-> Contains metadata about project/package/application.
-> Contains dependencies.
-> Dependencies basically keep track of the various packages used in the project along with the specific versions.
-> To create a package.json file before installing packages, we run 'npm init'.
-> Typically added in the root directory of the project.
-> We do not share the node_modules folder on github(or any other platform), i.e) we usually hide it, for memory purposes.
-> Whenever someone else uses the project, all they have to do is run 'npm install' which will automatically install all the dependencies present on the package.json folder


EXPRESS:
-> Express is a Node Package
-> Web Framework for node js.
-> Helps us start a server to listen for requests
-> Parses incoming requests 
-> Matches requests to particular routes.
-> Helps us craft our http response and associated content.
-> Run 'npm install express' to install the node modules required for express



CREATING A SERVER:
-> To create a server, we use the app.listen method and specify a port number.
-> To open the server, we go to our browser and type in 'localhost:<port_number>'
e.g)
const express = require('express');
const app = express();

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



REQUESTING AND SENDING RESPONSES:
-> To perform an action anytime we get a request to our server, we implement the app.use method
-> The app.use method has two objects made automatically by express. These are req and res which contain information about the request and response respectively.
-> The req object has info like the pathname requested, etc.
-> The res object has a method called 'send' which is used to send a response back to the server for a incoming request.
e.g)
const express = require('express');
const app = express();

app.use((req, res) => {
    console.log('We got a new request');              //shows up in terminal 
    res.send('Hello we got your request, this is a response');           //shows up in browser
    //res.send({ color : 'red' });
    //res.send('<h1>This is my webpage!</h1>');
})
app.listen(3000, () => {
    console.log('Listening on port 3000');
})



ROUTING:
-> Taking incoming requests along with a path that is requested and matching it to a code and response.
-> Paths can be /cats => 'meow' , /dogs => 'woof' , /
-> To send responses for particular get requests, we implement the app.get method.
-> To send responses for particular post requests, we implement the app.post method.
-> We cannot have an HTTP request that gets more than one response.
e.g)
const express = require('express');
const app = express();

app.get('/', (req, res) => {                               //Basically localhost:3000 (i.e. starting page)
    console.log('This is the home page');
})
app.get('/cats', (req, res) => {
    res.send('meow');
})
app.post('/cats', (req, res) => {
    res.send('Post Request to /cats. This is different than a get request');
})
app.get('/dogs', (req, res) => {
    res.send('woof');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> We can specify a '*' route which basically means everything.
-> It is important to add this in the end so that none of responses for the stuff we have declared get overrided.
e.g)
const express = require('express');
const app = express();

app.get('/', (req, res) => {                               //Basically localhost:3000 (i.e. starting page)
    console.log('This is the home page');
})
app.get('/cats', (req,res) => {
    res.send('meow');
})
app.get('*', (req, res) => {
    res.send('I do not know that path');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



PATH PARAMETERS:
-> To use routes which can have varying path values, we implement '/:<name>'
-> A response is sent for any name provided.
e.g)
const express = require('express');
const app = express();

app.get('/r/:subreddit' , (req, res) => {
    res.send('This is a subreddit');
})
app.get('/r/:subreddit/:postid' , (req, res) => {
    res.send('This is a subreddit');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> To extract and use the name provided to 'subreddit' we can implement req.params
e.g)
const express = require('express');
const app = express();

app.get('/r/:subreddit/:postid' , (req, res) => {
    const{ subreddit , postid } = req.params;
    res.send(`<h1>Viewing Post ID : ${postid} on the ${subreddit} subreddit</h1>`);
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



QUERY STRINGS:
-> Query strings are present after a link and are used to filter out resources from a set of resources.
-> It starts with a '?' and is followed by key value pairs seperated by '&'
e.g)
localhost:8080/r/birds?name=cookie&color=blue
-> In express, the request object contains a 'query' object which contains key value pairs of all query strings provided in the request.
e.g)
const express = require('express');
const app = express();

app.get('/search' , (req, res) => {
    const{ name } = req.query;
    if(!q){
        res.send('Nothing Found If Nothing Searched');
    }
    res.send(`<h1>Search results for: ${name}</h1>`);
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



NODEMON:
-> Automatically restarts server when we change our code.
-> Instead of using 'node <file_name>' , we run 'nodemon <file_name>' 
-> Anytime we change any js/json file, nodemon restarts the server.



TEMPLATING:
-> Allows us to define a preset pattern for a webpage that we can dynamically modify.
-> We shall use EJS(Embedded javascript) to implement templating.



CONFIGURING EXPRESS FOR EJS:
-> We need to tell express to use EJS 
-> To do this we can implement the app.set method
-> We then run 'npm install ejs'
e.g)
const express = require('express');
const app = express();

app.set('view engine', 'ejs');

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> By deafult, when we create a new express app and use a view engine, express assumes that our templates are present in a directory called 'views' (by default).
-> We can change this default directory using app.set
-> The created templates which are present within the 'views' folder must have a file extension of '.ejs'
-> We then use the res.render('<file_name>') method in the app.get method to render the .ejs file and any javascript present within it. 
e.g)
const express = require('express');
const app = express();

app.set('view engine', 'ejs');

app.get('/', (req, res) => {
    res.render('home.ejs');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> If we try to run our application from a different working directory, the 'views' folder will not be present in our working directory and we will not have access to the .ejs files for our program to render.
-> To overcome this, we do:
e.g)
const express = require('express');
const app = express();
const path = require('path');   

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'))

app.get('/', (req, res) => {
    res.render('home.ejs');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



EJS Interpolation Syntax:
-> Anything present between <%= %> will be treated as javascript in an ejs file.


PASSING DATA TO TEMPLATES:
-> In the app.get method, we define data and pass it as an object of keys(variable names) and values(variable values) in the render function as the second argument after the .ejs file name.
-> We can then use these variables in the .ejs file by simply adding the variable names in between <%= %>.   
e.g)
const express = require('express');
const app = express();
const path = require('path');   

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'))

app.get('/', (req, res) => {
    res.render('home.ejs');
})

app.get('/rand', (req, res) => {
    const num = Math.floor(Math.random() * 10) + 1;
    res.render('random', { rand : num });
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

(random.ejs file)
<h1>Hello <%= rand %></h1>



CONDITIONALS IN EJS:
-> To write out conditional statements in js (code that will not get rendered onto the webpage but are needed for checking conditions), we add the js code within <% %>
-> This indicates that js code is present to control the flow but will not be rendered.
e.g)
<body>
    <h1>Homepage <%= rand %></h1>
    <% if(rand % 2 === 0){ %>
    <h2>This is an even number</h2>
    <% } else{ %>
    <h2>This is an odd number</h2>
    <% }%> 
</body>


SERVING STATIC FILES:
-> Usually standalone css and js files will not be included in the server.
-> To include these static files, we need to use the following command:
e.g)
app.use(express.static(path.join(__dirname, 'public')));
-> It is best practice to add all static file contents to a public folder so that we can run the above command.
Note:- The public folder must be present in the same directory as the index.js file.
-> When we link these files with html/ejs files, we do not have to provide the entire path. We need to reference the path from the directory mentioned in the above command.(public in this case)
e.g)
<link rel="stylesheet" href="/css/style.css">


PARTIALS:
-> Including templates inside of other templates.
-> To do this, we add our template code onto an ejs file and then in the ejs file where we want to add the templated code, we use <%- include('<path_from_cwd>')%>
-> When we are making templated html code, we do not need to specify the structure of the html document. (no need to specify head, etc)
-> Best to have a subdirectory called partials which includes all the partial templates.
 