TERMINAL:
-> Text based prompt used to interact with the machine.
-> Terminal is faster
-> Shell is the program running on the Terminal


COMMANDS:
-> The 'ls' command lists all the directories present in the current directory.
-> The 'pwd' command lists out the current directory path.
-> The 'cd <new_dir_name>' command changes the current working directory to a directory present within the current working directory.
-> The 'cd ..' command moves the working directory to the parent directory of the current working directory.

-> Absolute paths are those that can be referenced from any folder in the computer whereas relative paths are those that can only be accessed from the working directory.
e.g)
-> Absolute Path:
Note- The '\' signifies the root directory
cd \Users\sudee
cd \
-> Realtive Path:
Assuming we are in Courses folder, 
cd 'Web Development'/Notes
cd ../Sem-V

-> The 'mkdir <new_dir_name>' creates a new folder/directory in the current working directory. We can create multiple new directories/folders.
-> The 'man <command>' command provides us with a description of the specified command along with the flags we can use on it.
-> The 'touch <file_name>.<extension>' command creates files in the working directory. We can create multiple files at a time. Also sets the modification and access times in files.
-> The 'rm <file_names>' command can be used to remove files. Can remove multiple files at once. Once removed, cannot be restored again.
-> The 'rmdir <folder_name>' command can be used to remove folders. Can only remove empty folders.
-> The 'rm -rf <folder_name>' command can be used to remove folders that have contents within them. Once removed, cannot be restored again.


NODE JS:
-> JavaScript runtime
-> Implementation of JavaScript that runs outside the browser. 
-> Used to create Web Servers, video games, drone software, native apps(vs code), command line tools.


NODE REPL:
-> Its the equivalent of the JavaScript web console but on the terminal.
-> To activate, type 'node' in the terminal and enter.
-> DOM API's are not present.
-> The 'global' scope(contains setTimeout, etc) in the node REPL is the the equivalent of the window (top level element)
-> Contains modules that can interact with files and do other stuff the web browser cannot.


RUNNING FILES IN NODE:
-> To run files in node, first create a JavaScript file and in the node repl, run 'node <file_name>' .This will run the javascript file.
-> The import(python) equivalent in javascript is require()
e.g)
const fs = require('fs');


PROCESS:
-> Object in global that provides information about and control over the current Node.js process.
-> Always available to Node.js applications without the need of require().
-> Has info like current working directory, memory usage, etc.  
-> process.argv property returns an array containing the command line arguments passed when the node.js process was launched.
-> The first element will be process.execPath (Where the node executable is)
-> The second element will be the file that we are executing.
-> The remaining elements will be any arguments passed during launch.
e.g)
node greeter.js sudeev sunil


MODULE EXPORTS:
-> We can export certain variables, functions from a javascript file onto other files.
-> There exists a module.exports object (default to an empty object) to which we can add on our properties and methods.
-> Only the properties, methods added onto the module.exports object can be required from another file.
e.g)
(math.js file)
const add = (x,y) => x + y;
const PI = 3.14;
const square = x => x * x;
module.exports.add = add;
module.exports.PI = PI;
module.exports.square = square;

(app.js file)
const math = require('./math');               // '.' refers to the current directory
console.log(math);                            // Will contain add, PI and square properties/methods

-> We can also create an object containing all the necessary information to export and then assign the module.exports object with our created object.
e.g) module.exports = <created_object>;


REQUIRING A DIRECTORY:
-> When we want to require the contents of an entire directory, we create a index.js file in the directory exporting all the necessary information from that directory.
-> When node tries to require the contents of a directory, it searches for an index.js file in the directory and requires everything from the index.js file only.
e.g)
(cookie.js file)
module.exports = {
    name : 'cookie',
    color : 'blue'
};

(lovely.js file)
module.exports = {
    name : 'lovely',
    color : 'yellow'
};

(index.js file)
const cookie = require('./cookie');
const lovely = require('./lovely');
const allPets = [cookie,lovely];
module.exports = allPets;

(All the above files are in a Pets folder)

(app.js file present in the same directory as the Pets folder)
const pets = require('./Pets');
console.log(pets);                          //will print [ { name : 'cookie', color : 'blue' } , { name : 'lovely' , color : 'yellow' } ] 


NPM:
-> Node Package Manager
-> Library of thousands of packages published by other developers that we can use for free.
-> Command line tool to easily install and manage the packages in our node projects.
-> Kind of like pip for python 
-> 'npm install <package_name>' installs the package locally in the working directory.
-> 'npm install -g <package_name>' installs the package globally.


PACKAGE.JSON FILE:
-> Contains metadata about project/package/application.
-> Contains dependencies.
-> Dependencies basically keep track of the various packages used in the project along with the specific versions.
-> To create a package.json file before installing packages, we run 'npm init'.
-> Typically added in the root directory of the project.
-> We do not share the node_modules folder on github(or any other platform), i.e) we usually hide it, for memory purposes.
-> Whenever someone else uses the project, all they have to do is run 'npm install' which will automatically install all the dependencies present on the package.json folder


EXPRESS:
-> Express is a Node Package
-> Web Framework for node js.
-> Helps us start a server to listen for requests
-> Parses incoming requests 
-> Matches requests to particular routes.
-> Helps us craft our http response and associated content.
-> Run 'npm install express' to install the node modules required for express



CREATING A SERVER:
-> To create a server, we use the app.listen method and specify a port number.
-> To open the server, we go to our browser and type in 'localhost:<port_number>'
e.g)
const express = require('express');
const app = express();

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



REQUESTING AND SENDING RESPONSES:
-> To perform an action anytime we get a request to our server, we implement the app.use method
-> The app.use method has two objects made automatically by express. These are req and res which contain information about the request and response respectively.
-> The req object has info like the pathname requested, etc.
-> The res object has a method called 'send' which is used to send a response back to the server for a incoming request.
e.g)
const express = require('express');
const app = express();

app.use((req, res) => {
    console.log('We got a new request');              //shows up in terminal 
    res.send('Hello we got your request, this is a response');           //shows up in browser
    //res.send({ color : 'red' });
    //res.send('<h1>This is my webpage!</h1>');
})
app.listen(3000, () => {
    console.log('Listening on port 3000');
})



ROUTING:
-> Taking incoming requests along with a path that is requested and matching it to a code and response.
-> Paths can be /cats => 'meow' , /dogs => 'woof' , /
-> To send responses for particular get requests, we implement the app.get method.
-> To send responses for particular post requests, we implement the app.post method.
-> We cannot have an HTTP request that gets more than one response.
e.g)
const express = require('express');
const app = express();

app.get('/', (req, res) => {                               //Basically localhost:3000 (i.e. starting page)
    console.log('This is the home page');
})
app.get('/cats', (req, res) => {
    res.send('meow');
})
app.post('/cats', (req, res) => {
    res.send('Post Request to /cats. This is different than a get request');
})
app.get('/dogs', (req, res) => {
    res.send('woof');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> We can specify a '*' route which basically means everything.
-> It is important to add this in the end so that none of responses for the stuff we have declared get overrided.
e.g)
const express = require('express');
const app = express();

app.get('/', (req, res) => {                               //Basically localhost:3000 (i.e. starting page)
    console.log('This is the home page');
})
app.get('/cats', (req,res) => {
    res.send('meow');
})
app.get('*', (req, res) => {
    res.send('I do not know that path');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



PATH PARAMETERS:
-> To use routes which can have varying path values, we implement '/:<name>'
-> A response is sent for any name provided.
e.g)
const express = require('express');
const app = express();

app.get('/r/:subreddit' , (req, res) => {
    res.send('This is a subreddit');
})
app.get('/r/:subreddit/:postid' , (req, res) => {
    res.send('This is a subreddit');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> To extract and use the name provided to 'subreddit' we can implement req.params
e.g)
const express = require('express');
const app = express();

app.get('/r/:subreddit/:postid' , (req, res) => {
    const{ subreddit , postid } = req.params;
    res.send(`<h1>Viewing Post ID : ${postid} on the ${subreddit} subreddit</h1>`);
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



QUERY STRINGS:
-> Query strings are present after a link and are used to filter out resources from a set of resources.
-> It starts with a '?' and is followed by key value pairs seperated by '&'
e.g)
localhost:8080/r/birds?name=cookie&color=blue
-> In express, the request object contains a 'query' object which contains key value pairs of all query strings provided in the request.
e.g)
const express = require('express');
const app = express();

app.get('/search' , (req, res) => {
    const{ name } = req.query;
    if(!q){
        res.send('Nothing Found If Nothing Searched');
    }
    res.send(`<h1>Search results for: ${name}</h1>`);
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



NODEMON:
-> Automatically restarts server when we change our code.
-> Instead of using 'node <file_name>' , we run 'nodemon <file_name>' 
-> Anytime we change any js/json file, nodemon restarts the server.
