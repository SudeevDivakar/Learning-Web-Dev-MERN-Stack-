TERMINAL:
-> Text based prompt used to interact with the machine.
-> Terminal is faster
-> Shell is the program running on the Terminal


COMMANDS:
-> The 'ls' command lists all the directories present in the current directory.
-> The 'pwd' command lists out the current directory path.
-> The 'cd <new_dir_name>' command changes the current working directory to a directory present within the current working directory.
-> The 'cd ..' command moves the working directory to the parent directory of the current working directory.

-> Absolute paths are those that can be referenced from any folder in the computer whereas relative paths are those that can only be accessed from the working directory.
e.g)
-> Absolute Path:
Note- The '\' signifies the root directory
cd \Users\sudee
cd \
-> Realtive Path:
Assuming we are in Courses folder, 
cd 'Web Development'/Notes
cd ../Sem-V

-> The 'mkdir <new_dir_name>' creates a new folder/directory in the current working directory. We can create multiple new directories/folders.
-> The 'man <command>' command provides us with a description of the specified command along with the flags we can use on it.
-> The 'touch <file_name>.<extension>' command creates files in the working directory. We can create multiple files at a time. Also sets the modification and access times in files.
-> The 'rm <file_names>' command can be used to remove files. Can remove multiple files at once. Once removed, cannot be restored again.
-> The 'rmdir <folder_name>' command can be used to remove folders. Can only remove empty folders.
-> The 'rm -rf <folder_name>' command can be used to remove folders that have contents within them. Once removed, cannot be restored again.


NODE JS:
-> JavaScript runtime
-> Implementation of JavaScript that runs outside the browser. 
-> Used to create Web Servers, video games, drone software, native apps(vs code), command line tools.


NODE REPL:
-> Its the equivalent of the JavaScript web console but on the terminal.
-> To activate, type 'node' in the terminal and enter.
-> DOM API's are not present.
-> The 'global' scope(contains setTimeout, etc) in the node REPL is the the equivalent of the window (top level element)
-> Contains modules that can interact with files and do other stuff the web browser cannot.


RUNNING FILES IN NODE:
-> To run files in node, first create a JavaScript file and in the node repl, run 'node <file_name>' .This will run the javascript file.
-> The import(python) equivalent in javascript is require()
e.g)
const fs = require('fs');


PROCESS:
-> Object in global that provides information about and control over the current Node.js process.
-> Always available to Node.js applications without the need of require().
-> Has info like current working directory, memory usage, etc.  
-> process.argv property returns an array containing the command line arguments passed when the node.js process was launched.
-> The first element will be process.execPath (Where the node executable is)
-> The second element will be the file that we are executing.
-> The remaining elements will be any arguments passed during launch.
e.g)
node greeter.js sudeev sunil


MODULE EXPORTS:
-> We can export certain variables, functions from a javascript file onto other files.
-> There exists a module.exports object (default to an empty object) to which we can add on our properties and methods.
-> Only the properties, methods added onto the module.exports object can be required from another file.
e.g)
(math.js file)
const add = (x,y) => x + y;
const PI = 3.14;
const square = x => x * x;
module.exports.add = add;
module.exports.PI = PI;
module.exports.square = square;

(app.js file)
const math = require('./math');               // '.' refers to the current directory
console.log(math);                            // Will contain add, PI and square properties/methods

-> We can also create an object containing all the necessary information to export and then assign the module.exports object with our created object.
e.g) module.exports = <created_object>;


REQUIRING A DIRECTORY:
-> When we want to require the contents of an entire directory, we create a index.js file in the directory exporting all the necessary information from that directory.
-> When node tries to require the contents of a directory, it searches for an index.js file in the directory and requires everything from the index.js file only.
e.g)
(cookie.js file)
module.exports = {
    name : 'cookie',
    color : 'blue'
};

(lovely.js file)
module.exports = {
    name : 'lovely',
    color : 'yellow'
};

(index.js file)
const cookie = require('./cookie');
const lovely = require('./lovely');
const allPets = [cookie,lovely];
module.exports = allPets;

(All the above files are in a Pets folder)

(app.js file present in the same directory as the Pets folder)
const pets = require('./Pets');
console.log(pets);                          //will print [ { name : 'cookie', color : 'blue' } , { name : 'lovely' , color : 'yellow' } ] 


NPM:
-> Node Package Manager
-> Library of thousands of packages published by other developers that we can use for free.
-> Command line tool to easily install and manage the packages in our node projects.
-> Kind of like pip for python 
-> 'npm install <package_name>' installs the package locally in the working directory.
-> 'npm install -g <package_name>' installs the package globally.


PACKAGE.JSON FILE:
-> Contains metadata about project/package/application.
-> Contains dependencies.
-> Dependencies basically keep track of the various packages used in the project along with the specific versions.
-> To create a package.json file before installing packages, we run 'npm init'.
-> Typically added in the root directory of the project.
-> We do not share the node_modules folder on github(or any other platform), i.e) we usually hide it, for memory purposes.
-> Whenever someone else uses the project, all they have to do is run 'npm install' which will automatically install all the dependencies present on the package.json folder


EXPRESS:
-> Express is a Node Package
-> Web Framework for node js.
-> Helps us start a server to listen for requests
-> Parses incoming requests 
-> Matches requests to particular routes.
-> Helps us craft our http response and associated content.
-> Run 'npm install express' to install the node modules required for express



CREATING A SERVER:
-> To create a server, we use the app.listen method and specify a port number.
-> To open the server, we go to our browser and type in 'localhost:<port_number>'
e.g)
const express = require('express');
const app = express();

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



REQUESTING AND SENDING RESPONSES:
-> To perform an action anytime we get a request to our server, we implement the app.use method
-> The app.use method has two objects made automatically by express. These are req and res which contain information about the request and response respectively.
-> The req object has info like the pathname requested, etc.
-> The res object has a method called 'send' which is used to send a response back to the server for a incoming request.
e.g)
const express = require('express');
const app = express();

app.use((req, res) => {
    console.log('We got a new request');              //shows up in terminal 
    res.send('Hello we got your request, this is a response');           //shows up in browser
    //res.send({ color : 'red' });
    //res.send('<h1>This is my webpage!</h1>');
})
app.listen(3000, () => {
    console.log('Listening on port 3000');
})



ROUTING:
-> Taking incoming requests along with a path that is requested and matching it to a code and response.
-> Paths can be /cats => 'meow' , /dogs => 'woof' , /
-> To send responses for particular get requests, we implement the app.get method.
-> To send responses for particular post requests, we implement the app.post method.
-> We cannot have an HTTP request that gets more than one response.
e.g)
const express = require('express');
const app = express();

app.get('/', (req, res) => {                               //Basically localhost:3000 (i.e. starting page)
    console.log('This is the home page');
})
app.get('/cats', (req, res) => {
    res.send('meow');
})
app.post('/cats', (req, res) => {
    res.send('Post Request to /cats. This is different than a get request');
})
app.get('/dogs', (req, res) => {
    res.send('woof');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> We can specify a '*' route which basically means everything.
-> It is important to add this in the end so that none of responses for the stuff we have declared get overrided.
e.g)
const express = require('express');
const app = express();

app.get('/', (req, res) => {                               //Basically localhost:3000 (i.e. starting page)
    console.log('This is the home page');
})
app.get('/cats', (req,res) => {
    res.send('meow');
})
app.get('*', (req, res) => {
    res.send('I do not know that path');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



PATH PARAMETERS:
-> To use routes which can have varying path values, we implement '/:<name>'
-> A response is sent for any name provided.
e.g)
const express = require('express');
const app = express();

app.get('/r/:subreddit' , (req, res) => {
    res.send('This is a subreddit');
})
app.get('/r/:subreddit/:postid' , (req, res) => {
    res.send('This is a subreddit');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> To extract and use the name provided to 'subreddit' we can implement req.params
e.g)
const express = require('express');
const app = express();

app.get('/r/:subreddit/:postid' , (req, res) => {
    const{ subreddit , postid } = req.params;
    res.send(`<h1>Viewing Post ID : ${postid} on the ${subreddit} subreddit</h1>`);
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



QUERY STRINGS:
-> Query strings are present after a link and are used to filter out resources from a set of resources.
-> It starts with a '?' and is followed by key value pairs seperated by '&'
e.g)
localhost:8080/r/birds?name=cookie&color=blue
-> In express, the request object contains a 'query' object which contains key value pairs of all query strings provided in the request.
e.g)
const express = require('express');
const app = express();

app.get('/search' , (req, res) => {
    const{ name } = req.query;
    if(!q){
        res.send('Nothing Found If Nothing Searched');
    }
    res.send(`<h1>Search results for: ${name}</h1>`);
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



NODEMON:
-> Automatically restarts server when we change our code.
-> Instead of using 'node <file_name>' , we run 'nodemon <file_name>' 
-> Anytime we change any js/json file, nodemon restarts the server.



TEMPLATING:
-> Allows us to define a preset pattern for a webpage that we can dynamically modify.
-> We shall use EJS(Embedded javascript) to implement templating.



CONFIGURING EXPRESS FOR EJS:
-> We need to tell express to use EJS 
-> To do this we can implement the app.set method
-> We then run 'npm install ejs'
e.g)
const express = require('express');
const app = express();

app.set('view engine', 'ejs');

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> By deafult, when we create a new express app and use a view engine, express assumes that our templates are present in a directory called 'views' (by default).
-> We can change this default directory using app.set
-> The created templates which are present within the 'views' folder must have a file extension of '.ejs'
-> We then use the res.render('<file_name>') method in the app.get method to render the .ejs file and any javascript present within it. 
e.g)
const express = require('express');
const app = express();

app.set('view engine', 'ejs');

app.get('/', (req, res) => {
    res.render('home.ejs');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

-> If we try to run our application from a different working directory, the 'views' folder will not be present in our working directory and we will not have access to the .ejs files for our program to render.
-> To overcome this, we do:
e.g)
const express = require('express');
const app = express();
const path = require('path');   

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'))

app.get('/', (req, res) => {
    res.render('home.ejs');
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})



EJS Interpolation Syntax:
-> Anything present between <%= %> will be treated as javascript in an ejs file.


PASSING DATA TO TEMPLATES:
-> In the app.get method, we define data and pass it as an object of keys(variable names) and values(variable values) in the render function as the second argument after the .ejs file name.
-> We can then use these variables in the .ejs file by simply adding the variable names in between <%= %>.   
e.g)
const express = require('express');
const app = express();
const path = require('path');   

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, '/views'))

app.get('/', (req, res) => {
    res.render('home.ejs');
})

app.get('/rand', (req, res) => {
    const num = Math.floor(Math.random() * 10) + 1;
    res.render('random', { rand : num });
})

app.listen(3000, () => {
    console.log('Listening on port 3000');
})

(random.ejs file)
<h1>Hello <%= rand %></h1>



CONDITIONALS IN EJS:
-> To write out conditional statements in js (code that will not get rendered onto the webpage but are needed for checking conditions), we add the js code within <% %>
-> This indicates that js code is present to control the flow but will not be rendered.
e.g)
<body>
    <h1>Homepage <%= rand %></h1>
    <% if(rand % 2 === 0){ %>
    <h2>This is an even number</h2>
    <% } else{ %>
    <h2>This is an odd number</h2>
    <% }%> 
</body>


SERVING STATIC FILES:
-> Usually standalone css and js files will not be included in the server.
-> To include these static files, we need to use the following command:
e.g)
app.use(express.static(path.join(__dirname, 'public')));
-> It is best practice to add all static file contents to a public folder so that we can run the above command.
Note:- The public folder must be present in the same directory as the index.js file.
-> When we link these files with html/ejs files, we do not have to provide the entire path. We need to reference the path from the directory mentioned in the above command.(public in this case)
e.g)
<link rel="stylesheet" href="/css/style.css">


PARTIALS:
-> Including templates inside of other templates.
-> To do this, we add our template code onto an ejs file and then in the ejs file where we want to add the templated code, we use <%- include('<path_from_cwd>')%>
-> When we are making templated html code, we do not need to specify the structure of the html document. (no need to specify head, etc)
-> Best to have a subdirectory called partials which includes all the partial templates.


GET vs POST REQUESTS:
-> Get requests are used to retrieve information 
-> Data in a get request is sent via a query string.
-> This information is clearly visible in the URL.
-> Limited amount of data can be sent this way.
e.g)
<form action="/tacos" method="get">
    <input type="text" name="type">
    <input type="text" name="qty">
    <button>Submit</button>
</form>                                  //shows values in the query string

<form action="/tacos" method="post">
    <input type="text" name="type">
    <input type="text" name="qty">
    <button>Submit</button>             //send values in the request body 
</form>


DEFINING EXPRESS POST ROUTES:
-> POST requests are used when we want to create something with account details or we want to add content, etc.
-> All we do for this is change the method to 'post'
e.g)
<form action="/tacos" method="post">
    <input type="text" name="type">
    <input type="text" name="qty">
    <button>Submit</button>
</form>

app.post('/tacos', (req, res) => {
    res.send('POST /tacos response');
})


PARSING THE REQUEST BODY:
-> In the case of post requests, the req object has a 'body' property which contains the information sent.
-> We need to specify how to parse these request bodies. By deafult req.body is undefined. 
-> To parse form encoded information from the request body, run the following line of code
e.g) 
app.use(express.urlencoded({ extended : true  }));
-> Similarly, if we want to parse json data, we can use the line of code:
e.g)
app.use(express.json());

-> Once we use the above line of code, we can destructure req.body and extract out all the data.
e.g)
const express = require('express');
const app = express();

app.use(express.json());
app.use(express.urlencoded({ extended : true }));

app.post('/tacos', (req, res) => {
    const { type, qty } = req.body;
    res.send(`POST /tacos response for ${type} and ${qty}`);
})


REST:
-> Representational State Transfer
-> Architectural style for distributed hypermedia systems
-> Basically a set of guidelines for how client + server should communicate and perform CRUD operations on a given resource.
-> We use different HTTP verbs for the different CRUD operations we need to perform in our project.
-> GET for getting values, POST for inserting data, PATCH for updating and DELETE for deleting data.
-> We also try to follow the same names for the different routes we create along with different HTTP verbs.
e.g)
GET /comments - list all comments
POST /comments - Create a new comment
GET /comments/:id - Get one comment (using ID)
PATCH /comments/:id - Update one comment 
DELETE /comments/:id - Removes one comment 


EXPRESS REDIRECTS:
-> We should never render a template in a post request because, if we reload the page, the same post request with the same body details will
be sent everytime we refresh which might result in unwanted results.
-> The response object has a method called redirect which redirects us to a url that we specify.
e.g)
app.post('/comments', (req, res) => {
    const { username, comment } = req.body;
    const newComment = { username : username , comment : comment };
    comments.push(newComment);
    res.redirect('/comments');
})


UUID:
-> Universely unique identifier
-> NPM package we need to install and require
e.g)
npm install uuid 
const { v4 : uuidv4 } = require('uuid');
uuidv4();     // Returns an universely unique identifier which we can use in our program


REQUESTS USED FOR UPDATING:
-> PUT : The PUT method replaces all current representations of the target resource with the request payload. Basically used when we need to change an entire existing resource.
-> PATCH : The PATCH method is used to apply partial modifications to a resource. Basically used when we need to update/add something to an existing resource.
Note :- We can use either of these where ever and however we want. The above definitions are just guidelines for the same.


EXPRESS METHOD OVERRIDE:
-> HTML forms in the browser can only send GET and POST requests. They cannot send patch, put, delete and other request types.
-> To overcome this, we use a method-override npm package which allows us to use patch or any other request types not supported by the browser.
e.g)
var methodOverride = require('method-override');
app.use(methodOverride('_method'));

<form method="POST" action="/resource?_method=DELETE">
  <button type="submit">Delete resource</button>
</form>



DATABASES:
-> Used to save data
-> Can store a lot of data and store it compactly 
-> Provides tools for easy access and insertion of data 
-> Offers Security as well
-> Generally scale very well


SQL Databases:
-> Structured query language
-> Relational databases 
-> Predefined schema which has to be followed 
-> Tables connected to each other based on certain attributes 
e.g)
MySQL, Postgres, SQLite, Oracle


NoSQL Databases:
-> No predefined schema (flexible schema)
-> SQL not used 
e.g)
MongoDB, Neo4j, Cassandra, CouchDB




MongoDB:
-> Type in mongosh in the cmd to use the mongo shell 
-> 'db' is the database we use, by default it is set to 'test' in the mongo terminal.


SHOWING DATABASES:
e.g)
show dbs 
    (OR) 
show databases 


CREATING AND USING DATABASES:
e.g)
use <database_name>
Note:- We need to add content into the database for it to be saved.


BSON:
-> Binary JSON
-> JSON is very slow (text based format)
-> JSON is also not space efficient
-> Does not support a lot of datatypes
-> BSON is a more compact version of JSON 
-> MongoDB stores data in the form of BSON 
-> BSON supports extra datatypes like date, etc.


INSERTING INTO MongoDB:
-> Collections in MongoDB are basically tables where we store documents of similar information 
-> Inserting data into a collection that does not exist, creates a new collection and inserts the data into it 
-> The three different ways to insert data into the mongoDB database are:
i) db.collection.insertOne({})          //inserts one object into the collection
ii) db.collection.insertMany([{},{}])    // inserts many objects which should be present within an array   
iii) db.collection.insert()                // can do both of the above mentioned statements.
Note :- The 'show collections' command lists out all the collections present in the database 
Note :- If the '_id' field is not specified while inserting, mongoDB will automatically insert an '_id' field with the document. This '_id' field acts as a primary key.


FINDING IN MongoDB:
-> To return all the documents in a collection, use:
e.g)
db.<collection_name>.find()
-> To find a specific document in the collection, use:
e.g)
db.<collection_name>.find({<key1> : <value1> , <key2> : <value2>})
-> To find only one document from the collection, use:
e.g)
db.<collection_name>.findOne({<key> : <value>})
Note :- findOne() returns the actual document whereas find() returns a cursor (pointer to the results)


UPDATING IN MongoDB:
-> To update the first match of the specified conditions, use:
e.g)
db.<collection_name>.updateOne(<filter> , <update> , <options>) 
db.<collection_name>.updateOne({name : "Cookie"} , {$set : {color : "blue"}})
Note :- We can update multiple keys using this method. If we try to set a non-existent new key, it creates a new key and sets the value.
-> To update all matches, use:
e.g)
db.<collection_name>.updateMany(<filter> , <update> , <options>) 
db.<collection_name>.updateMany({name : "Cookie"} , {$set : {color : "blue"}})
-> To replace the all the contents of a document, use:
e.g)
db.<collection_name>.replaceOne(<filter> , <update> , <options>) 


DELETING IN MongoDB:
-> To delete the first match from a collection, use:
e.g)
db.<collection_name>.deleteOne({<key1> : <value1> , <key2> : <value2>})
-> To delete many matches from a collection, use:
e.g)
db.<collection_name>.deleteMany({<key1> : <value1> , <key2> : <value2>})
-> To delete all documents from a collection, use:
e.g)
db.<collection_name>.deleteMany({})


OTHER OPERATORS IN MongoDB:
-> Suppose we have,
{
    '_id' : 1,
    name : 'Cookie',
    personality : {
        catFriendly : 'NO',
        childFriendly : 'YES'
    }
}
-> Now to write a query to find matches that are childFriendly, use:
e.g)
db.birds.find({'personality.childFriendly' : 'YES' , name : 'Cookie'})

-> Comparison Operators
e.g)
$eq, $gt, $gte, $lt, $lte, $in, $ne, $nin(matches none of the values present in the array)
-> To find greater than values, use:
e.g) 
db.<collection_name>.find({ qty : { $gt : 20 } })
-> To find matches in arrays, use:
e.g)
db.<collection_name>.find({breed: {$in: ['budgie', 'parrot']}})

-> Logical Operators
e.g)
$and, $not, $or, $nor
-> To find matches with either of two given conditions being satisfied, use:
e.g)
db.<collection_name>.find({ $or: [{qty : {$lt : 30}}, {price : 10}] })

-> Geography Data Operators (Geospatial)
e.g) 
$geoIntersects, $geoWithin, $near, $nearSphere

